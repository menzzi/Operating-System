# 과제02

```c
 /* Default FCFS resource acquision function */
bool fcfs_acquire(int resource_id)
{
	struct resource *r = resources + resource_id;

	if (!r->owner) {
		/* This resource is not owned by any one. Take it! */
		r->owner = current;
		return true;
	}

	/* OK, this resource is taken by @r->owner. */

	/* Update the current process state */
	current->status = PROCESS_WAIT;

	/* And append current to waitqueue */
	list_add_tail(&current->list, &r->waitqueue);

	/**
	 * And return false to indicate the resource is not available.
	 * The scheduler framework will soon call schedule() function to
	 * schedule out current and to pick the next process to run.
	 */
	return false;
}
/* Default FCFS resource release function */
void fcfs_release(int resource_id)
{
	struct resource *r = resources + resource_id;

	/* Ensure that the owner process is releasing the resource */
	assert(r->owner == current);

	/* Un-own this resource */
	r->owner = NULL;

	/* Let's wake up ONE waiter (if exists) that came first */
	if (!list_empty(&r->waitqueue)) {
		struct process *waiter =
				list_first_entry(&r->waitqueue, struct process, list);

		/**
		 * Ensure the waiter is in the wait status
		 */
		assert(waiter->status == PROCESS_WAIT);

		/**
		 * Take out the waiter from the waiting queue. Note we use
		 * list_del_init() over list_del() to maintain the list head tidy
		 * (otherwise, the framework will complain on the list head
		 * when the process exits).
		 */
		list_del_init(&waiter->list);

		/* Update the process status */
		waiter->status = PROCESS_READY;

		/**
		 * Put the waiter process into ready queue. The framework will
		 * do the rest.
		 */
		list_add_tail(&waiter->list, &readyqueue);
	}
}

```

- 기본 FCFS 스켈레톤 코드이다.

### 1. FIFO scheduler

:  선입선처리 스케줄링 -> 말 그대로 먼저 들어온 프로세스 순서대로 실행한다.
  - 장점 = 단순하다. 모든 프로세스가 실행될 수 있다.
  - 단점 = 앞의 프로세스의 수행시간이 길면 대기시간이 늘어난다. (짧고 간단한 작업들이 계속 기다려야하는 상황이 올 수 있다.)

  ```c
  static int fifo_initialize(void)
{
	return 0;
}

static void fifo_finalize(void)
{
}

static struct process *fifo_schedule(void)
{
	struct process *next = NULL;
	/* 이전 틱에서 실행할 프로세스가 없을때, 또는 현재 프로세스 상태가 WAIT 상태면 다음 프로세스 선택 */
	if (!current || current->status == PROCESS_WAIT) {
		goto pick_next;
	}

	/* 현재 프로세스 수명이 남아있으면 스케줄링 */
	if (current->age < current->lifespan) {
		return current;
	}

pick_next:
	/* 다음에 실행할 새로운 프로세스 선택 */

	if (!list_empty(&readyqueue)) {
		/* readyqueue 가 비어있지 않다면 readyqueue에서 첫번째 프로세스 선택 */
		next = list_first_entry(&readyqueue, struct process, list);

		/* ready queue에서 프로세스 제거, ist_del_init()를 사용하여 목록 헤드를 깔끔하게 유지 */
		list_del_init(&next->list);
	}

	return next;
}

struct scheduler fifo_scheduler = {
	.name = "FIFO",
	.acquire = fcfs_acquire,
	.release = fcfs_release,
	.initialize = fifo_initialize,
	.finalize = fifo_finalize,
	.schedule = fifo_schedule,
};

  ```

### 2. SJF scheduler
: 최소 작업 우선 스케줄링 -> 프로세서가 사용 가능할 때 실행 시간이 가장 짧은 작업에 할당하는 방법이다.
 - 장점 = 평균 대기 시간이 가장 짧다.
 - 단점 = 초기의 긴 작업을 짧은 작업을 종료할 때 까지 대기시켜 Starvation 발생한다.
	기본적으로 짧은 작업이 항상 실행되도록 설정하므로 불공정한 작업을 실행한다.
	실행 시간을 예측하기 어려워 실용적이지 못하다.

```c
static struct process *sjf_schedule(void)
{
	struct process *next = NULL;
	struct process *p;
	unsigned int shortTime = 20;

	if(!current || current->status == PROCESS_WAIT){
		goto pick_next;
	}

	if(current->age < current->lifespan){
		return current;
	}
pick_next:

	if(!list_empty(&readyqueue)){
		
		list_for_each_entry(p,&readyqueue,list){

			/* 수명이 가장 지금까지 실행시간보다 짧은지 확인 */
			if(p->lifespan < shortTime){ // true
				shortTime = p->lifespan; //shortTime 변수 업데이트
				next = p;
			}

		}

		list_del_init(&next->list);
	}	

	return next;
}

struct scheduler sjf_scheduler = {
	.name = "Shortest-Job First",
	.acquire = fcfs_acquire, /* Use the default FCFS acquire() */
	.release = fcfs_release, /* Use the default FCFS release() */
	.schedule = sjf_schedule,		
       	/* TODO: Assign sjf_schedule()
	to this function pointer to activate
			SJF in the system */
};

```


