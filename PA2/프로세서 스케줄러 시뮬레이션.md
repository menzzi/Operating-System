# ê³¼ì œ02

#### CPU ìŠ¤ì¼€ì¤„ë§ ì•Œê³ ë¦¬ì¦˜ì˜ ëª©ì  (: ì¼ë°˜ì ì¸ ì‹œìŠ¤í…œì—ì„œëŠ” ë‹¤ìŒê³¼ ê°™ì€ ëª©ì ì„ ê³µí†µì ìœ¼ë¡œ ì§€ë‹Œë‹¤.)

- No starvation : ê°ê°ì˜ í”„ë¡œì„¸ìŠ¤ë“¤ì´ ì˜¤ëžœì‹œê°„ë™ì•ˆ CPUë¥¼ í• ë‹¹ë°›ì§€ ëª»í•˜ëŠ” ìƒí™©ì´ ì—†ë„ë¡ í•œë‹¤.
- Fairness : ê°ê°ì˜ í”„ë¡œì„¸ìŠ¤ì— ê³µí‰í•˜ê²Œ CPUë¥¼ í• ë‹¹í•´ì¤€ë‹¤.
- Balance : Keeping all parts of the system busy

##### ìŠ¤ì¼€ì¤„ë§ ì¢…ë¥˜
1. FIFO
2. SJF
3. SRTF
4. RR
5. Priority (Aging, PCP, PIP)
---

###### ê¸°ë³¸ FCFS ìŠ¤ì¼ˆë ˆí†¤ ì½”ë“œ
```c
 /* Default FCFS resource acquision function */
bool fcfs_acquire(int resource_id)
{
	struct resource *r = resources + resource_id;

	if (!r->owner) {
		/* This resource is not owned by any one. Take it! */
		r->owner = current;
		return true;
	}

	/* OK, this resource is taken by @r->owner. */

	/* Update the current process state */
	current->status = PROCESS_WAIT;

	/* And append current to waitqueue */
	list_add_tail(&current->list, &r->waitqueue);

	/**
	 * And return false to indicate the resource is not available.
	 * The scheduler framework will soon call schedule() function to
	 * schedule out current and to pick the next process to run.
	 */
	return false;
}
/* Default FCFS resource release function */
void fcfs_release(int resource_id)
{
	struct resource *r = resources + resource_id;

	/* Ensure that the owner process is releasing the resource */
	assert(r->owner == current);

	/* Un-own this resource */
	r->owner = NULL;

	/* Let's wake up ONE waiter (if exists) that came first */
	if (!list_empty(&r->waitqueue)) {
		struct process *waiter =
				list_first_entry(&r->waitqueue, struct process, list);

		/**
		 * Ensure the waiter is in the wait status
		 */
		assert(waiter->status == PROCESS_WAIT);

		/**
		 * Take out the waiter from the waiting queue. Note we use
		 * list_del_init() over list_del() to maintain the list head tidy
		 * (otherwise, the framework will complain on the list head
		 * when the process exits).
		 */
		list_del_init(&waiter->list);

		/* Update the process status */
		waiter->status = PROCESS_READY;

		/**
		 * Put the waiter process into ready queue. The framework will
		 * do the rest.
		 */
		list_add_tail(&waiter->list, &readyqueue);
	}
}

``` 
*ìœ„ ì½”ë“œë¥¼ ì°¸ê³ í•˜ì—¬ ì§„í–‰*

### 1. FIFO scheduler

:  ì„ ìž…ì„ ì²˜ë¦¬ ìŠ¤ì¼€ì¤„ë§ -> ë§ ê·¸ëŒ€ë¡œ ë¨¼ì € ë“¤ì–´ì˜¨ í”„ë¡œì„¸ìŠ¤ ìˆœì„œëŒ€ë¡œ ì‹¤í–‰í•œë‹¤.
  - ìž¥ì  = ë‹¨ìˆœí•˜ë‹¤. ëª¨ë“  í”„ë¡œì„¸ìŠ¤ê°€ ì‹¤í–‰ë  ìˆ˜ ìžˆë‹¤.
  - ë‹¨ì  = ì•žì˜ í”„ë¡œì„¸ìŠ¤ì˜ ìˆ˜í–‰ì‹œê°„ì´ ê¸¸ë©´ ëŒ€ê¸°ì‹œê°„ì´ ëŠ˜ì–´ë‚œë‹¤. (ì§§ê³  ê°„ë‹¨í•œ ìž‘ì—…ë“¤ì´ ê³„ì† ê¸°ë‹¤ë ¤ì•¼í•˜ëŠ” ìƒí™©ì´ ì˜¬ ìˆ˜ ìžˆë‹¤.) -> ```convey effect```
  - **Non-preemptive, No starvation**

  ```c
  static int fifo_initialize(void)
{
	return 0;
}

static void fifo_finalize(void)
{
}

static struct process *fifo_schedule(void)
{
	struct process *next = NULL;
	/* ì´ì „ í‹±ì—ì„œ ì‹¤í–‰í•  í”„ë¡œì„¸ìŠ¤ê°€ ì—†ì„ë•Œ, ë˜ëŠ” í˜„ìž¬ í”„ë¡œì„¸ìŠ¤ ìƒíƒœê°€ WAIT ìƒíƒœë©´ ë‹¤ìŒ í”„ë¡œì„¸ìŠ¤ ì„ íƒ */
	if (!current || current->status == PROCESS_WAIT) {
		goto pick_next;
	}

	/* í˜„ìž¬ í”„ë¡œì„¸ìŠ¤ ìˆ˜ëª…ì´ ë‚¨ì•„ìžˆìœ¼ë©´ ìŠ¤ì¼€ì¤„ë§ */
	if (current->age < current->lifespan) {
		return current;
	}

pick_next:
	/* ë‹¤ìŒì— ì‹¤í–‰í•  ìƒˆë¡œìš´ í”„ë¡œì„¸ìŠ¤ ì„ íƒ */

	if (!list_empty(&readyqueue)) {
		/* readyqueueê°€ ë¹„ì–´ìžˆì§€ ì•Šë‹¤ë©´ readyqueueì—ì„œ ì²« ë²ˆì§¸ í”„ë¡œì„¸ìŠ¤ ì„ íƒ */
		next = list_first_entry(&readyqueue, struct process, list);

		/* ready queueì—ì„œ í”„ë¡œì„¸ìŠ¤ ì œê±°, ist_del_init()ë¥¼ ì‚¬ìš©í•˜ì—¬ ëª©ë¡ í—¤ë“œë¥¼ ê¹”ë”í•˜ê²Œ ìœ ì§€ */
		list_del_init(&next->list);
	}

	return next;
}

struct scheduler fifo_scheduler = {
	.name = "FIFO",
	.acquire = fcfs_acquire,
	.release = fcfs_release,
	.initialize = fifo_initialize,
	.finalize = fifo_finalize,
	.schedule = fifo_schedule,
};

  ```

### 2. SJF scheduler
: ìµœì†Œ ìž‘ì—… ìš°ì„  ìŠ¤ì¼€ì¤„ë§ -> í”„ë¡œì„¸ì„œê°€ ì‚¬ìš© ê°€ëŠ¥í•  ë•Œ ì‹¤í–‰ ì‹œê°„ì´ ê°€ìž¥ ì§§ì€ ìž‘ì—…ì— í• ë‹¹í•˜ëŠ” ë°©ë²•ì´ë‹¤.
 - ìž¥ì  = í‰ê·  ëŒ€ê¸° ì‹œê°„ì´ ê°€ìž¥ ì§§ë‹¤.
 - ë‹¨ì  = ì´ˆê¸°ì˜ ê¸´ ìž‘ì—…ì„ ì§§ì€ ìž‘ì—…ì„ ì¢…ë£Œí•  ë•Œ ê¹Œì§€ ëŒ€ê¸°ì‹œì¼œ Starvation ë°œìƒí•œë‹¤.  
	 ê¸°ë³¸ì ìœ¼ë¡œ ì§§ì€ ìž‘ì—…ì´ í•­ìƒ ì‹¤í–‰ë˜ë„ë¡ ì„¤ì •í•˜ë¯€ë¡œ ë¶ˆê³µì •í•œ ìž‘ì—…ì„ ì‹¤í–‰í•œë‹¤.  
	 ì‹¤í–‰ ì‹œê°„ì„ ì˜ˆì¸¡í•˜ê¸° ì–´ë ¤ì›Œ ì‹¤ìš©ì ì´ì§€ ëª»í•˜ë‹¤.  
- **Non-preemptive , starvation ë°œìƒ ê°€ëŠ¥**

```c
static struct process *sjf_schedule(void)
{
	struct process *next = NULL;
	struct process *p;
	unsigned int shortTime = 20;

	if(!current || current->status == PROCESS_WAIT){
		goto pick_next;
	}

	if(current->age < current->lifespan){
		return current;
	}
pick_next:

	if(!list_empty(&readyqueue)){
		
		list_for_each_entry(p,&readyqueue,list){

			/* ìˆ˜ëª…ì´ ê°€ìž¥ ì§€ê¸ˆê¹Œì§€ ì‹¤í–‰ì‹œê°„ë³´ë‹¤ ì§§ì€ì§€ í™•ì¸ */
			if(p->lifespan < shortTime){ // true
				shortTime = p->lifespan; // shortTime ë³€ìˆ˜ ì—…ë°ì´íŠ¸
				next = p;
			}
		}

		list_del_init(&next->list);
	}	

	return next;
}

struct scheduler sjf_scheduler = {
	.name = "Shortest-Job First",
	.acquire = fcfs_acquire, /* Use the default FCFS acquire() */
	.release = fcfs_release, /* Use the default FCFS release() */
	.schedule = sjf_schedule,		
       	/* TODO: Assign sjf_schedule()
	to this function pointer to activate
			SJF in the system */
};

```

### 3. SRTF scheduler
: Shortest Remaining Time First -> ì–´ë–¤ ìƒˆë¡œìš´ jobì´ ë“¤ì–´ì™”ì„ ë•Œ, ê° taskë“¤ì˜ ë‚¨ì€ ì‹œê°„ì„ ë”°ì ¸ë³´ê³  ê°€ìž¥ ì§§ì€ í”„ë¡œì„¸ìŠ¤ì—ì„œ í• ë‹¹í•˜ëŠ” ë°©ì‹ì´ë‹¤.
- ìž¥ì  : í‰ê·  ë°˜í™˜ì‹œê°„ì„ ê°œì„ í•œë‹¤.
- ë‹¨ì  : ìš´ì˜ì²´ì œëŠ” Ready Queueì— ìžˆëŠ” í”„ë¡œì„¸ìŠ¤ì˜ ì‹¤í–‰ì‹œê°„ì„ ì•Œì§€ ëª»í•œë‹¤.  
	ìž¦ì€ ì„ ì ìœ¼ë¡œ ë¬¸ë§¥ êµí™˜/ì˜¤ë²„í—¤ë“œê°€ ì¦ê°€í•œë‹¤.  
	ì‹¤í–‰ ì‹œê°„ì´ ê¸´ í”„ë¡œì„¸ìŠ¤ë“¤ì˜ í‰ê·  ì‘ë‹µ ì‹œê°„ ê¸¸ì–´ì§„ë‹¤.  
- **SJF ë°©ì‹ì˜ Preemptive ë²„ì „, Starvationì´ ë°œìƒ ê°€ëŠ¥**

```c
 static struct process *srtf_schedule(void){

	struct process *next = NULL;
	struct process *temp; // ë‚¨ì€ ì‹œê°„ì— ë”°ë¼ ì‹¤í–‰ë˜ëŠ” í”„ë¡œì„¸ìŠ¤ê°€ ë‹¬ë¼ì§€ë‹ˆ ì €ìž¥í•˜ê¸° ìœ„í•œ temp
	struct process *p;
	unsigned int shortTime = 20;

	if(!current || current -> status == PROCESS_WAIT){
		goto pick_next;
	}

	if(current->age < current->lifespan){
		
		int remain = current->lifespan - current->age; // ë‚¨ì€ ì‹¤í–‰ ì‹œê°„ ê³„ì‚°
		list_add(&current->list,&readyqueue); // í˜„ìž¬ í”„ë¡œì„¸ìŠ¤ë¥¼ readyqueueì— ì¶”ê°€	
		list_for_each_entry(temp,&readyqueue,list){
			if(temp->lifespan < remain){
  				/* í˜„ìž¬ê¹Œì§€ í™•ì¸í•œ í”„ë¡œì„¸ìŠ¤ì˜ ìˆ˜ëª…ì´ ë‚¨ì€ ì‹¤í–‰ ì‹œê°„ë³´ë‹¤ ì§§ë‹¤ë©´,
  				remainì„ í•´ë‹¹ í”„ë¡œì„¸ìŠ¤ì˜ ìˆ˜ëª…ìœ¼ë¡œ ì—…ë°ì´íŠ¸í•˜ê³  currentë¥¼ í•´ë‹¹ í”„ë¡œì„¸ìŠ¤ë¡œ ì„¤ì • */
				remain = temp->lifespan;
				current = temp;
			}	
		}
		list_del_init(&current->list);
		return current;
	}
	pick_next:

	if(!list_empty(&readyqueue)){
 
		list_for_each_entry(p,&readyqueue,list){

			if(p->lifespan < shortTime){
				shortTime = p->lifespan;
				next = p;
			}
		}
		list_del_init(&next->list);
	}	
	return next;
}

struct scheduler srtf_scheduler = {
	.name = "Shortest Remaining Time First",
	.acquire = fcfs_acquire, /* Use the default FCFS acquire() */
	.release = fcfs_release, /* Use the default FCFS release() */
	/* You need to check the newly created processes to implement SRTF.
	 * Use @forked() callback to mark newly created processes */
	/* Obviously, you should implement srtf_schedule() and attach it here */

	.schedule = srtf_schedule,
};

```

### 4. Round-robin scheduler
: ëª¨ë“  jobì„ time slice(=scheduling quantum)ì˜ í¬ê¸°ë¡œ ìª¼ê°œê³ , í•œ slice ì”© ëª¨ë“  taskë“¤ì„ concurrent í•˜ê²Œ ëŒë¦¬ëŠ” ë°©ì‹ì´ë‹¤.
- ìž¥ì  : response timeì„ ê°œì„ í•œë‹¤. FCFSì—ì„œ convoy effectë¥¼ ë³´ì™„í•œ í˜•íƒœì´ë‹¤.
- time slice â¬†ï¸ : responsive ì¤„ì–´ë“ ë‹¤.  /  time slice â¬‡ï¸ : context switch overhead ë„ˆë¬´ í¬ë‹¤. => time quantum ê²°ì • ë¬¸ì œê°€ êµ‰ìž¥ížˆ ì¤‘ìš”ðŸŒŸ
- cpu bound job ì´ io bound job ì— ë¹„í•´ ë” ìœ ë¦¬í•˜ë‹¤.

> Round-Robin ìŠ¤ì¼€ì¤„ë§ì€ ë‹¤ì¤‘ í”„ë¡œì„¸ìŠ¤ë¥¼ ì²˜ë¦¬í•˜ëŠ” ìŠ¤ì¼€ì¤„ë§ ì•Œê³ ë¦¬ì¦˜ ì¤‘ í•˜ë‚˜ìž…ë‹ˆë‹¤. ì´ ë°©ì‹ì—ì„œ ê° í”„ë¡œì„¸ìŠ¤ëŠ” ë™ì¼í•œ ì‹œê°„ ìŠ¬ë¼ì´ìŠ¤(quantum)ë¥¼ í• ë‹¹ë°›ê³  CPUë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤. ë§Œì•½ í•´ë‹¹ ì‹œê°„ ë‚´ì— ìž‘ì—…ì´ ì™„ë£Œë˜ì§€ ì•Šìœ¼ë©´ ë‹¤ìŒ ìˆœì„œì˜ í”„ë¡œì„¸ìŠ¤ê°€ ì‹¤í–‰ë©ë‹ˆë‹¤. ì´ê²ƒì€ í”„ë¡œì„¸ìŠ¤ ê°„ì— ê³µì •í•œ ë¶„ë°°ë¥¼ ë³´ìž¥í•©ë‹ˆë‹¤.  
> > CPU ë°”ìš´ë“œ ìž‘ì—…ì€ CPUë¥¼ ë§Žì´ ì‚¬ìš©í•˜ëŠ” ìž‘ì—…ì´ê¸° ë•Œë¬¸ì—, RR ìŠ¤ì¼€ì¤„ë§ì´ ì´ì— ìœ ë¦¬í•©ë‹ˆë‹¤. ê° ìž‘ì—…ì€ ë™ì¼í•œ ì‹œê°„ ìŠ¬ë¼ì´ìŠ¤ë¥¼ í• ë‹¹ë°›ê³  ì‹¤í–‰ë˜ë¯€ë¡œ CPU ë°”ìš´ë“œ ìž‘ì—…ì´ ê³µì •í•˜ê²Œ ì‹¤í–‰ë  ìˆ˜ ìžˆìŠµë‹ˆë‹¤. ì´ëŠ” ê° ìž‘ì—…ì´ CPUë¥¼ ì‚¬ìš©í•˜ëŠ” ê¸°ê°„ì„ ê³ ë¥´ê²Œ ë¶„ë°°í•˜ë¯€ë¡œ ì‹œìŠ¤í…œì˜ ì „ì²´ ì„±ëŠ¥ì„ ê· í˜• ìžˆê²Œ ìœ ì§€í•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤.  
ë°˜ë©´, I/O ë°”ìš´ë“œ ìž‘ì—…ì€ ëŒ€ë¶€ë¶„ì˜ ì‹œê°„ì„ ìž…ì¶œë ¥ ìž‘ì—…ì— ì‚¬ìš©í•˜ë¯€ë¡œ CPUë¥¼ ë§Žì´ ì‚¬ìš©í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ë”°ë¼ì„œ RR ìŠ¤ì¼€ì¤„ë§ì€ ì´ëŸ¬í•œ ìž‘ì—…ì— ëŒ€í•´ì„œëŠ” íš¨ìœ¨ì ì´ì§€ ì•Šì„ ìˆ˜ ìžˆìŠµë‹ˆë‹¤. ëŒ€ì‹ , ìž…ì¶œë ¥ ìž‘ì—…ì´ ë°œìƒí•  ë•Œë§ˆë‹¤ CPUë¥¼ ë†€ë¦¬ê³  ë‹¤ë¥¸ ìž‘ì—…ì„ ì²˜ë¦¬í•˜ëŠ” ë°©ì‹ì´ ë” íš¨ê³¼ì ì¼ ìˆ˜ ìžˆìŠµë‹ˆë‹¤.

- **Preemptive, No starvation**
  
```c
static struct process *rr_schedule(void){
	
	struct process *next = NULL;
	
	if(!current || current -> status == PROCESS_WAIT){
		goto pick_next;
	}

	if(current->age < current->lifespan){
		list_add_tail(&current->list,&readyqueue); // í˜„ìž¬ í”„ë¡œì„¸ìŠ¤ ë¦¬ìŠ¤íŠ¸ ëì— ë„£ì–´ì¤Œ
		current = list_first_entry(&readyqueue, struct process,list); //ë¦¬ìŠ¤íŠ¸ì˜ ë§¨ ì•ž í”„ë¡œì„¸ìŠ¤ êº¼ë‚´ì˜´
		list_del_init(&current->list); // êº¼ë‚¸ í”„ë¡œì„¸ìŠ¤ ì œê±°
		return current;
	}
	// FIFO ì™€ ë‹¤ë¥¸ ë¶€ë¶„!! -> RRì„ circular FIFOë¡œ ë³¼ ìˆ˜ ìžˆë‹¤.
pick_next:

	if(!list_empty(&readyqueue)){
		next = list_first_entry(&readyqueue,struct process,list);
		list_del_init(&next->list);
	}
	return next;
}

struct scheduler rr_scheduler = {
	.name = "Round-Robin",
	.acquire = fcfs_acquire, /* Use the default FCFS acquire() */
	.release = fcfs_release, /* Use the default FCFS release() */
	/* Obviously, you should implement rr_schedule() and attach it here */

	.schedule = rr_schedule,
};

```

> ë¬¸ì œ ì¡°ê±´ : For round-robin scheduler, you don't need to worry about managing the time quantum;
> the simulator will automatically call the schedule() function whenever the time quantum expires.
> In other words, the time quantum coincides with the tick. If two processes are with the same priority, they should be run for one tick by turn.

âž¡ï¸ ë”°ë¡œ time sliceë¥¼ ì§€ì •í•˜ì§€ ì•Šì•„ë„ ëœë‹¤. 

### 5. Priority scheduler
: ê°ê°ì˜ jobë“¤ì€ priorityë¥¼ ê°€ì§€ê³  ìžˆê³ , ê·¸ priorityì— ë”°ë¼ì„œ ì‹¤í–‰ìˆœì„œë¥¼ ì •í•´ì£¼ëŠ” ë°©ì‹ì´ë‹¤.
- ë¬¸ì œì  : ë¬´í•œ ì •ì§€ì™€ Starvation (í•´ê²°ì±… - aging, priority boosting ) / priority inversion problem (í•´ê²°ì±… - PCP, PIP)
  > priority inversion problem
  > : ì–´ë–¤ priority ìŠ¤ì¼€ì¤„ ì‹œìŠ¤í…œì—ì„œ ë‚®ì€ priority taskê°€ high priority taskê°€ í•„ìš”ë¡œí•˜ëŠ” ìžì›ì„ ìž ê¹ ìž¡ê³  ìžˆëŠ” ì‚¬ì´ ê·¸ ì‹œì ì— lowë³´ë‹¤ëŠ” ë†’ê³  highë³´ë‹¤ëŠ” ë‚®ì€ ì œ 3ì˜ priority í”„ë¡œì„¸ìŠ¤ê°€ ë¼ì–´ë“¤ì–´ high priority taskê°€ ë”ì´ìƒ ì§„í–‰í•˜ì§€ ëª»í•˜ë„ë¡ í•˜ëŠ” ë¬¸ì œì ì´ë‹¤.
- **Preemptive, Starvation**
  
```c
bool prio_acquire(int resource_id){
	struct resource *r = resources + resource_id;

	/* í•´ë‹¹ ë¦¬ì†ŒìŠ¤ì— ëŒ€í•œ ì†Œìœ ê¶Œì´ ì—†ìœ¼ë¯€ë¡œ í˜„ìž¬ í”„ë¡œì„¸ìŠ¤ê°€ ì´ë¥¼ ì†Œìœ . */
	if(!r->owner){ 
		r->owner = current;
		return true;
	}
	/* ìžì›ì„ ëª» ìž¡ìœ¼ë©´ WAIT ìƒíƒœ ì²˜ë¦¬ í•´ì£¼ê³ , waitqueueì— ë„£ì€ í›„ false ë°˜í™˜.	*/
	current ->status = PROCESS_WAIT;

	list_add_tail(&current->list , &r->waitqueue);

	return false;
	
}
void prio_release(int resource_id){
	
	struct resource *r = resources + resource_id;
	struct process *waiter = NULL;
	struct process *p;
	int highPrio = 0;

	assert(r->owner == current); // í•´ë‹¹ ë¦¬ì†ŒìŠ¤ì˜ ì†Œìœ ìžê°€ ì•„ë‹ˆë©´ ì˜¤ë¥˜ ì¶œë ¥ í›„ ì¢…ë£Œ.

	r->owner = NULL; // í•´ë‹¹ ë¦¬ì†ŒìŠ¤ì˜ ì†Œìœ ìžë¥¼ í•´ì œ.
	
	if(!list_empty(&r->waitqueue)){
		list_for_each_entry(p,&r->waitqueue,list){
			if(p->prio >= highPrio){
				highPrio = p->prio;
				waiter = p;
				// ê°€ìž¥ ë†’ì€ ìš°ì„ ìˆœìœ„ë¥¼ ê°€ì§„ í”„ë¡œì„¸ìŠ¤ ì°¾ê¸°. 
			}
		}
		assert(waiter->status == PROCESS_WAIT); // ê°€ìž¥ ë†’ì€ ìš°ì„ ìˆœìœ„ë¥¼ ê°€ì§„ í”„ë¡œì„¸ìŠ¤ê°€ WAIT ìƒíƒœê°€ ì•„ë‹ˆë©´ ì˜¤ë¥˜ ì¶œë ¥ í›„ ì¢…ë£Œ.

		list_del_init(&waiter->list); // ëŒ€ê¸° íì—ì„œ ì œê±°.

		waiter -> status = PROCESS_READY;

		list_add_tail(&waiter->list, &readyqueue); // ì¤€ë¹„ í ëì— add.
	}
}
static struct process *prio_schedule(void){

	struct process *next = NULL;
	struct process *temp;
	struct process *p;
	int highPrio = 0;

	if(!current || current->status == PROCESS_WAIT){
		goto pick_next;
	}

	if(current->age < current->lifespan){
		
		int remain = current->prio; //í˜„ìž¬ í”„ë¡œì„¸ìŠ¤ì˜ ìš°ì„ ìˆœìœ„
		list_add(&current->list,&readyqueue);
		list_for_each_entry(temp,&readyqueue,list){
			if(temp->prio > remain){
				remain = temp->prio;
				current = temp;
				// í˜„ìž¬ í”„ë¡œì„¸ìŠ¤ì˜ ìš°ì„ ìˆœìœ„ë³´ë‹¤ ë” ë†’ì€ ìš°ì„ ìˆœìœ„ë¥¼ ê°€ì§„ í”„ë¡œì„¸ìŠ¤ê°€ ìžˆëŠ” ê²½ìš°
			}
		}
		list_del_init(&current->list);
		
		return current;
	}
pick_next:

	if(!list_empty(&readyqueue)){
		list_for_each_entry(p,&readyqueue,list){
			// readyqueueì—ì„œ ìš°ì„ ìˆœìœ„ê°€ ê°€ìž¥ ë†’ì€ í”„ë¡œì„¸ìŠ¤ ì„ íƒ
			if(p->prio >= highPrio){
				highPrio = p->prio;
				next = p;
			}
		}
		list_del_init(&next->list);

	}
	return next;

}
struct scheduler prio_scheduler = {
	.name = "Priority",
	/**
	 * Implement your own acqure/release function to make priority
	 * scheduler correct.
	 */
	/* Implement your own prio_schedule() and attach it here */

	.acquire = prio_acquire,
	.release = prio_release,
	.schedule = prio_schedule,

};

```
#### 5-1) Priority scheduler with aging
: ì‹œê°„ì´ ì§€ë‚˜ë©´ ì¡°ê¸ˆì”© ageë¥¼ ë¨¹ê³ , ì´ë¥¼ ë°˜ì˜í•˜ëŠ” ë°©ì‹ -> Starvation í•´ê²°

```c
static struct process *pa_schedule(void){

	struct process *next = NULL;
	struct process *temp;
	struct process *p;
	struct process *newcurrent;
	int highPrio = 0;

	if(!current || current ->status == PROCESS_WAIT){
		goto pick_next;
	}	
	
	if(current -> age < current -> lifespan){
		int remain = current -> prio; 
		list_add(&current -> list , &readyqueue);
		list_for_each_entry(temp,&readyqueue,list){
			temp->prio++; // readyqueueì— ìžˆëŠ” í”„ë¡œì„¸ìŠ¤ë“¤ì˜ ìš°ì„ ìˆœìœ„ ì¦ê°€(aging)
			if(temp -> prio >= remain){
				// ìš°ì„ ìˆœìœ„ê°€ ë†’ì€ í”„ë¡œì„¸ìŠ¤ ì„ íƒ
				remain = temp -> prio;
				newcurrent = temp;
			}
		}

		newcurrent->prio = newcurrent-> prio_orig; // ì„ íƒëœ í”„ë¡œì„¸ìŠ¤ì˜ ìš°ì„ ìˆœìœ„ë¥¼ ì´ˆê¸° ìš°ì„ ìˆœìœ„ë¡œ ì„¤ì •
		list_del_init(&newcurrent->list);

		return newcurrent;

	}
pick_next:

	if(!list_empty(&readyqueue)){
		list_for_each_entry(p,&readyqueue,list){
			p->prio ++;
			if(p->prio >= highPrio){
				highPrio = p->prio;
				next = p;
			}
		}
		next->prio = next -> prio_orig;
		list_del_init(&next->list);	
	}
	return next;

}

struct scheduler pa_scheduler = {
	.name = "Priority + aging",
	/**
	 * Implement your own acqure/release function to make priority
	 * scheduler correct.
	 */
	/* Implement your own prio_schedule() and attach it here */
	.acquire = prio_acquire,
	.release = prio_release,
	.schedule = pa_schedule,
};

```
#### 5-2) priority ceiling protocol (PCP)
: íŠ¹ì • í”„ë¡œì„¸ìŠ¤ê°€ resourceë¥¼ ìž¡ëŠ” ìˆœê°„ priorityë¥¼ ë¯¸ì¹œë“¯ì´ ë†’ì—¬ì£¼ëŠ” ê²ƒ  
  resourceë¥¼ release í•˜ëŠ” ìˆœê°„ ë‹¤ì‹œ priorityë¥¼ ì›ëž˜ëŒ€ë¡œ ëŒë ¤ë†“ëŠ” ë°©ì‹

```c
bool pcp_acquire(int resource_id){
	struct resource *r = resources + resource_id;

	if(!r->owner){
		current -> prio = MAX_PRIO; // ë¦¬ì†ŒìŠ¤ë¥¼ ìž¡ìžë§ˆìž priority í™• ì˜¬ë ¤ì¤€ë‹¤.(PCP)
		r->owner = current;
		return true;
	}

	current -> status = PROCESS_WAIT;

	list_add_tail(&current->list,&r->waitqueue);

	return false;
}

void pcp_release(int resource_id){
	
	struct resource *r = resources + resource_id;
	struct process *waiter = NULL;
	struct process *p;
	int highPrio = 0;

	assert(r->owner == current);
	
	current->prio = current->prio_orig; // releaseí• ë• ì›ëž˜ priorityë¡œ ëŒë ¤ë†“ëŠ”ë‹¤.

	r->owner = NULL;

	if(!list_empty(&r->waitqueue)){
		list_for_each_entry(p,&r->waitqueue,list){
			if(p->prio > highPrio){
				highPrio = p->prio;
				waiter = p;
			}
		}
		assert(waiter->status == PROCESS_WAIT);

		list_del_init(&waiter->list);

		waiter -> status = PROCESS_READY;

		list_add_tail(&waiter->list,&readyqueue);
	}
}

static struct process *pcp_schedule(void){
	struct process *next = list_first_entry(&readyqueue,struct process,list);
	struct process *temp;
	struct process *p;
	struct process *newcurrent = list_first_entry(&readyqueue,struct process,list);
	int highPrio = 0;
	
	if(!current || current->status == PROCESS_WAIT){
		goto pick_next;
	}	
	if(current -> age < current -> lifespan){

		list_add_tail(&current->list,&readyqueue);
		list_for_each_entry(temp,&readyqueue,list){
			if(temp->prio > highPrio){
				highPrio = temp -> prio;
				newcurrent = temp;
			}
		}
		list_del_init(&newcurrent->list);
		return newcurrent;
	}
pick_next:

	if(!list_empty(&readyqueue)){
		list_for_each_entry(p,&readyqueue,list){
			if(p->prio > highPrio){
				highPrio = p->prio;
				next = p;
			}
		}
		list_del_init(&next->list);
		return next;
	}	
	return NULL;
	
}

struct scheduler pcp_scheduler = {
	.name = "Priority + PCP Protocol",
	/**
	 * Implement your own acqure/release function too to make priority
	 * scheduler correct.
	 */
	.acquire = pcp_acquire,
	.release = pcp_release,
	.schedule = pcp_schedule,
};

```

#### 5-3) priority inheritance protocol (PIP)
: high taskê°€ low taskê°€ ê°€ì§„ ìžì›ì´ í•„ìš”í•˜ë‹¤ë©´, í•„ìš”í•œ ìˆœê°„, lowì˜ priorityë¥¼ ì˜¬ë ¤ì£¼ëŠ” ê²ƒì´ë‹¤.

```c
bool pip_acquire(int resource_id){
	
	struct resource *r = resources + resource_id;

        if(!r->owner){
                r->owner = current;
                return true;
        }
	else if(current->prio > r->owner->prio) // ì´ë¯¸ ë¦¬ì†ŒìŠ¤ë¥¼ ì†Œìœ í•˜ê³  ìžˆëŠ” í”„ë¡œì„¸ìŠ¤ë³´ë‹¤ í˜„ìž¬ í”„ë¡œì„¸ìŠ¤ì˜ ìš°ì„  ìˆœìœ„ê°€ ë” ë†’ì€ ê²½ìš°.
		r->owner->prio = current->prio; // ë¦¬ì†ŒìŠ¤ë¥¼ ì†Œìœ í•˜ê³  ìžˆëŠ” í”„ë¡œì„¸ìŠ¤ì˜ ìš°ì„  ìˆœìœ„ë¥¼ í˜„ìž¬ í”„ë¡œì„¸ìŠ¤ì˜ ìš°ì„  ìˆœìœ„ë¡œ ì˜¬ë ¤ì¤Œ.(PIP)
        
	current -> status = PROCESS_WAIT; 
	// current : ìš°ì„ ìˆœìœ„ ì—­ì „ì„ ìœ ë°œí•˜ëŠ” í”„ë¡œì„¸ìŠ¤
        list_add_tail(&current->list,&r->waitqueue);

        return false;

}

void pip_release(int resource_id){
	
 	struct resource *r = resources + resource_id;
        struct process *waiter = NULL;
        struct process *p;
        int highPrio = 0;

        assert(r->owner == current);

        current->prio = current->prio_orig; // release í•  ë• ì›ëž˜ priorityë¡œ ë‹¤ì‹œ ì„¤ì •.

        r->owner = NULL;

        if(!list_empty(&r->waitqueue)){
                list_for_each_entry(p,&r->waitqueue,list){
                        if(p->prio >= highPrio){
                                highPrio = p->prio;
                                waiter = p;
                        }
                }
                assert(waiter->status == PROCESS_WAIT);

                list_del_init(&waiter->list);

                waiter -> status = PROCESS_READY;

                list_add_tail(&waiter->list,&readyqueue);
     
	}
}

static struct process *pip_schedule(void){ 
	struct process *next = list_first_entry(&readyqueue,struct process,list);
        struct process *temp;
        struct process *p;
        struct process *newcurrent = list_first_entry(&readyqueue,struct process,list);
        int highPrio = 0;

        if(!current || current->status == PROCESS_WAIT){
                goto pick_next;
        }
        if(current -> age < current -> lifespan){
		int remain = current->prio; 
                list_add_tail(&current->list,&readyqueue);
                list_for_each_entry(temp,&readyqueue,list){
                        if(temp->prio >= remain){
                                remain = temp -> prio;
                                newcurrent = temp;
                        }
                }
                list_del_init(&newcurrent->list);
                return newcurrent;
        }
pick_next:

        if(!list_empty(&readyqueue)){
                list_for_each_entry(p,&readyqueue,list){
                        if(p->prio > highPrio){
                                highPrio = p->prio;
                                next = p;
                        }
                }
                list_del_init(&next->list);
                return next;
        }
        return NULL;

}


struct scheduler pip_scheduler = {
	.name = "Priority + PIP Protocol",
	/**
	 * Ditto
	 */
	.acquire = pip_acquire,
	.release = pip_release,
	.schedule = pip_schedule,
};

```
