# 과제02

#### CPU 스케줄링 알고리즘의 목적 (: 일반적인 시스템에서는 다음과 같은 목적을 공통적으로 지닌다.)

- No starvation : 각각의 프로세스들이 오랜시간동안 CPU를 할당받지 못하는 상황이 없도록 한다.
- Fairness : 각각의 프로세스에 공평하게 CPU를 할당해준다.
- Balance : Keeping all parts of the system busy

##### 스케줄링 종류
1. FIFO
2. SJF
3. SRTF
4. RR
5. priority (aging, PCP, PIP)
---

###### 기본 FCFS 스켈레톤 코드
```c
 /* Default FCFS resource acquision function */
bool fcfs_acquire(int resource_id)
{
	struct resource *r = resources + resource_id;

	if (!r->owner) {
		/* This resource is not owned by any one. Take it! */
		r->owner = current;
		return true;
	}

	/* OK, this resource is taken by @r->owner. */

	/* Update the current process state */
	current->status = PROCESS_WAIT;

	/* And append current to waitqueue */
	list_add_tail(&current->list, &r->waitqueue);

	/**
	 * And return false to indicate the resource is not available.
	 * The scheduler framework will soon call schedule() function to
	 * schedule out current and to pick the next process to run.
	 */
	return false;
}
/* Default FCFS resource release function */
void fcfs_release(int resource_id)
{
	struct resource *r = resources + resource_id;

	/* Ensure that the owner process is releasing the resource */
	assert(r->owner == current);

	/* Un-own this resource */
	r->owner = NULL;

	/* Let's wake up ONE waiter (if exists) that came first */
	if (!list_empty(&r->waitqueue)) {
		struct process *waiter =
				list_first_entry(&r->waitqueue, struct process, list);

		/**
		 * Ensure the waiter is in the wait status
		 */
		assert(waiter->status == PROCESS_WAIT);

		/**
		 * Take out the waiter from the waiting queue. Note we use
		 * list_del_init() over list_del() to maintain the list head tidy
		 * (otherwise, the framework will complain on the list head
		 * when the process exits).
		 */
		list_del_init(&waiter->list);

		/* Update the process status */
		waiter->status = PROCESS_READY;

		/**
		 * Put the waiter process into ready queue. The framework will
		 * do the rest.
		 */
		list_add_tail(&waiter->list, &readyqueue);
	}
}

```


### 1. FIFO scheduler

:  선입선처리 스케줄링 -> 말 그대로 먼저 들어온 프로세스 순서대로 실행한다.
  - 장점 = 단순하다. 모든 프로세스가 실행될 수 있다.
  - 단점 = 앞의 프로세스의 수행시간이 길면 대기시간이 늘어난다. (짧고 간단한 작업들이 계속 기다려야하는 상황이 올 수 있다.) -> ```convey effect```
  - Non-preemptive, No starvation

  ```c
  static int fifo_initialize(void)
{
	return 0;
}

static void fifo_finalize(void)
{
}

static struct process *fifo_schedule(void)
{
	struct process *next = NULL;
	/* 이전 틱에서 실행할 프로세스가 없을때, 또는 현재 프로세스 상태가 WAIT 상태면 다음 프로세스 선택 */
	if (!current || current->status == PROCESS_WAIT) {
		goto pick_next;
	}

	/* 현재 프로세스 수명이 남아있으면 스케줄링 */
	if (current->age < current->lifespan) {
		return current;
	}

pick_next:
	/* 다음에 실행할 새로운 프로세스 선택 */

	if (!list_empty(&readyqueue)) {
		/* readyqueue 가 비어있지 않다면 readyqueue에서 첫번째 프로세스 선택 */
		next = list_first_entry(&readyqueue, struct process, list);

		/* ready queue에서 프로세스 제거, ist_del_init()를 사용하여 목록 헤드를 깔끔하게 유지 */
		list_del_init(&next->list);
	}

	return next;
}

struct scheduler fifo_scheduler = {
	.name = "FIFO",
	.acquire = fcfs_acquire,
	.release = fcfs_release,
	.initialize = fifo_initialize,
	.finalize = fifo_finalize,
	.schedule = fifo_schedule,
};

  ```

### 2. SJF scheduler
: 최소 작업 우선 스케줄링 -> 프로세서가 사용 가능할 때 실행 시간이 가장 짧은 작업에 할당하는 방법이다.
 - 장점 = 평균 대기 시간이 가장 짧다.
 - 단점 = 초기의 긴 작업을 짧은 작업을 종료할 때 까지 대기시켜 Starvation 발생한다.
	기본적으로 짧은 작업이 항상 실행되도록 설정하므로 불공정한 작업을 실행한다.
	실행 시간을 예측하기 어려워 실용적이지 못하다.
- Non-preemptive , starvation 발생 가능

```c
static struct process *sjf_schedule(void)
{
	struct process *next = NULL;
	struct process *p;
	unsigned int shortTime = 20;

	if(!current || current->status == PROCESS_WAIT){
		goto pick_next;
	}

	if(current->age < current->lifespan){
		return current;
	}
pick_next:

	if(!list_empty(&readyqueue)){
		
		list_for_each_entry(p,&readyqueue,list){

			/* 수명이 가장 지금까지 실행시간보다 짧은지 확인 */
			if(p->lifespan < shortTime){ // true
				shortTime = p->lifespan; //shortTime 변수 업데이트
				next = p;
			}

		}

		list_del_init(&next->list);
	}	

	return next;
}

struct scheduler sjf_scheduler = {
	.name = "Shortest-Job First",
	.acquire = fcfs_acquire, /* Use the default FCFS acquire() */
	.release = fcfs_release, /* Use the default FCFS release() */
	.schedule = sjf_schedule,		
       	/* TODO: Assign sjf_schedule()
	to this function pointer to activate
			SJF in the system */
};

```

### 3. SRTF scheduler
: Shortest Remaining Time First -> 어떤 새로운 job이 들어왔을 때, 각 task들의 남은 시간을 따져보고 가장 짧은 프로세스에서 할당하는 방식이다.
- 장점 : 평균 반환시간을 개선
- 단점 : 공정성, 응답시간 측면 단점이 있다. 또한 운영체제는 Ready Queue에 있는 프로세스의 실행시간을 알지 못한다.
- SJF 방식의 preemptive 버전, starvation이 발생 가능

```c
 static struct process *srtf_schedule(void){

	struct process *next = NULL;
	struct process *temp; // 남은 시간에 따라 실행되는 프로세스가 달라지니 저장하기 위한 temp
	struct process *p;
	unsigned int shortTime = 20;

	if(!current || current -> status == PROCESS_WAIT){
		goto pick_next;
	}

	if(current->age < current->lifespan){
		
		int remain = current->lifespan - current->age; // 남은 실행 시간 계산
		list_add(&current->list,&readyqueue); // 현재 프로세스를 readyqueue에 추가	
		list_for_each_entry(temp,&readyqueue,list){
			if(temp->lifespan < remain){
  				/* 현재까지 확인한 프로세스의 수명이 남은 실행 시간보다 짧다면,
  				remain을 해당 프로세스의 수명으로 업데이트하고 current를 해당 프로세스로 설정 */
				remain = temp->lifespan;
				current = temp;
			}	
		}
		list_del_init(&current->list);
		return current;
	}
	pick_next:

	if(!list_empty(&readyqueue)){
 
		list_for_each_entry(p,&readyqueue,list){

			if(p->lifespan < shortTime){
				shortTime = p->lifespan;
				next = p;
			}
		}
		list_del_init(&next->list);
	}	
	return next;
}

struct scheduler srtf_scheduler = {
	.name = "Shortest Remaining Time First",
	.acquire = fcfs_acquire, /* Use the default FCFS acquire() */
	.release = fcfs_release, /* Use the default FCFS release() */
	/* You need to check the newly created processes to implement SRTF.
	 * Use @forked() callback to mark newly created processes */
	/* Obviously, you should implement srtf_schedule() and attach it here */

	.schedule = srtf_schedule,
};

```

### 4. Round-robin scheduler
: 모든 job을 time slice(=scheduling quantum)의 크기로 쪼개고, 한 slice 씩 모든 task들을 concurrent 하게 돌리는 방식이다.
- 장점 : response time이 개선
- time slice ⬆️ : responsive 줄어든다.  /  time slice ⬇️ : context switch overhead 너무 크다.
- preemptive, No starvation

```c
static struct process *rr_schedule(void){
	
	struct process *next = NULL;
	
	if(!current || current -> status == PROCESS_WAIT){
		goto pick_next;
	}

	if(current->age < current->lifespan){
		list_add_tail(&current->list,&readyqueue); // 현재 프로세스 리스트 끝에 넣어줌
		current = list_first_entry(&readyqueue, struct process,list); //리스트의 맨 앞 프로세스 꺼내옴
		list_del_init(&current->list); // 꺼낸 프로세스 제거
		return current;
	}
	// FIFO 와 다른 부분!! -> RR을 circular FIFO로 볼 수 있다.
pick_next:

	if(!list_empty(&readyqueue)){
		next = list_first_entry(&readyqueue,struct process,list);
		list_del_init(&next->list);
	}
	return next;
}

struct scheduler rr_scheduler = {
	.name = "Round-Robin",
	.acquire = fcfs_acquire, /* Use the default FCFS acquire() */
	.release = fcfs_release, /* Use the default FCFS release() */
	/* Obviously, you should implement rr_schedule() and attach it here */

	.schedule = rr_schedule,
};

```

> 문제 조건 : For round-robin scheduler, you don't need to worry about managing the time quantum;
> the simulator will automatically call the schedule() function whenever the time quantum expires.
> In other words, the time quantum coincides with the tick. If two processes are with the same priority, they should be run for one tick by turn.

➡️ 따로 time slice를 지정하지 않아도 된다. 

### 5. Priority scheduler
: 각각의 job들은 priority를 가지고 있고, 그 priority에 따라서 실행순서를 정해주는 방식이다.
```c
```

